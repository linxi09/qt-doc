# 【NO.54】、Qt 添加菜单栏和工具栏

## 1、需求与目的

一般常规的PC软件都会有主窗口，主窗口中都会有菜单栏和工具栏，例如我们正在使用的Qt creator：
![image-20221214203427609](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203427609.png)

所以，工具栏和菜单栏的制作方法也是必须掌握的。

## 2、详细说明

首先需要先创建mainWindow设计师类，基类直接选择默认的MainWindow即可，然后就可以进行设计了，这里选择直接设计ui文件，下拉菜单无法直接输入中文，需要在其它地方输入中文后拷贝过来：
![image-20221214203436766](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203436766.png)

之后可以在Action Editor中找到菜单栏的动作选项：
![image-20221214203446070](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203446070.png)

可以看到这里可以设置对应动作的快捷键（不设置则使用默认的快捷键，如CTRL+C表示复制等），双击可以设置图标、对象名等信息：
![image-20221214203453975](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203453975.png)

右键单击可以找到转到槽，进行槽函数处理：
![image-20221214203504992](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203504992.png)

拖动到mainWindow菜单栏下方则成为工具栏的一部分，如果没有工具栏则右键窗口添加工具栏即可：
![image-20221214203513245](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203513245.png)

右键工具栏则可以添加分隔符，对于下拉菜单同理：
![image-20221214203523695](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203523695.png)

原文作者：十年编程老舅

原文地址：http://t.csdn.cn/I0PUn



# 【NO.55】、Qt QDockWidget 重叠方法

## 1、效果图片如下：

![image-20221214203538968](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203538968.png)

## 2、代码如下：

```
 1 void MainWindow::createDockWindows()
 2 
 3 {
 4     QDockWidget *dock = new QDockWidget(tr("Customers"), this);
 5 
 6     dock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
 7 
 8     customerList = new QListWidget(dock);
 9 
10     customerList->addItems(QStringList()
11 
12             << "John Doe, Harmony Enterprises, 12 Lakeside, Ambleton"
13 
14             << "Jane Doe, Memorabilia, 23 Watersedge, Beaton"
15 
16             << "Tammy Shea, Tiblanka, 38 Sea Views, Carlton"
17 
18             << "Tim Sheen, Caraba Gifts, 48 Ocean Way, Deal"
19 
20             << "Sol Harvey, Chicos Coffee, 53 New Springs, Eccleston"
21 
22             << "Sally Hobart, Tiroli Tea, 67 Long River, Fedula");
23 
24     dock->setWidget(customerList);
25 
26     addDockWidget(Qt::RightDockWidgetArea, dock);
27 
28     viewMenu->addAction(dock->toggleViewAction());
29 
30  
31 
32     QDockWidget * dock1 = new QDockWidget(tr("Paragraphs"), this);
33 
34     paragraphsList = new QListWidget(dock1);
35 
36     paragraphsList->addItems(QStringList()
37 
38             << "1"
39 
40             << "2 "
41 
42             << "4"
43 
44             << "5"
45 
46             << "6"
47 
48             << "7");
49 
50     dock1->setWidget(paragraphsList);
51 
52     addDockWidget(Qt::RightDockWidgetArea, dock1);
53 
54     viewMenu->addAction(dock1->toggleViewAction());
55 
56  
57 
58     tabifyDockWidget(dock, dock1);
59 
60     QDockWidget *dock2 = new QDockWidget(tr("Paragraphs"), this);
61 
62     addDockWidget(Qt::RightDockWidgetArea, dock2);
63 
64     viewMenu->addAction(dock2->toggleViewAction());
65 
66  
67 
68     tabifyDockWidget(dock1, dock2);
69 
70     QDockWidget *dock3 = new QDockWidget(tr("whb"), this);
71 
72     addDockWidget(Qt::RightDockWidgetArea, dock3);
73 
74     viewMenu->addAction(dock3->toggleViewAction());
75 
76 
77 
78     tabifyDockWidget(dock2, dock3);
79 
80     dock->raise();
81 
82  
83 
84     connect(customerList, SIGNAL(currentTextChanged(QString)),
85 
86             this, SLOT(insertCustomer(QString)));
87 
88     connect(paragraphsList, SIGNAL(currentTextChanged(QString)),
89 
90             this, SLOT(addParagraph(QString)));
91 
92 
```

原文作者：十年编程老舅

原文地址：http://t.csdn.cn/o34L6



# 【NO.56】、Qt QFutureWatcher实现图片缩放加载缩放的功能

简述

QFuture 表示异步计算的结果，QFutureWatcher 则允许使用信号和槽监视 QFuture，也就是说，QFutureWatcher 是为 QFuture 而生的。

## 1、详细描述

QFutureWatcher 提供了有关 QFuture 的信息和通知，使用 setFuture() 函数开始监视一个特定的 QFuture，函数 future() 则返回由 setFuture() 设置的 future。

为了方便，QFuture 的很多函数可以直接通过 QFutureWatcher 来访问，例如：progressValue()、progressMinimum()、progressMaximum()、progressText()、isStarted()、isFinished()、isRunning()、isCanceled()、isPaused()、waitForFinished()、result() 和 resultAt()。而 cancel()、setPaused()、pause()、resume() 和 togglePaused() 是 QFutureWatcher 中的槽函数。

状态更改由 started()、finished()、cancelled()、paused()、resumed()、resultReadyAt() 和 resultsReadyAt() 信号提供，进度信息由 progressRangeChanged()、progressValueChanged() 和progressTextChanged() 信号提供。

由函数 setPendingResultsLimit() 提供节流控制。当挂起的 resultReadyAt() 或 resultsReadyAt() 信号数量超过限制时，由 future 表示的计算将被自动节流。一旦挂起的信号数量下降到限制以下时，计算将恢复。

示例，开始计算并当完成时获取槽回调：

```
1 // 实例化对象，并连接到 finished() 信号。
2 MyClass myObject;
3 QFutureWatcher<int> watcher;
4 connect(&watcher, SIGNAL(finished()), &myObject, SLOT(handleFinished()));
5  
6 // 开始计算
7 QFuture<int> future = QtConcurrent::run(...);
8 watcher.setFuture(future);
```

## 2、基本使用

来看一个图像加载和缩放的示例。选择多个图片，进行异步计算（将所有图片进行缩放），加载过程中可以显示进度，以便我们实时了解进展。每当一个图片处理完成，就会显示在窗体中。

这里仅为了演示效果，加载了 8 张 图片。

![image-20221214203554123](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203554123.png)

具体的源码如下所示：

ImagesView.h：

```
 1 #ifndef IMAGES_VIEW_H
 2 #define IMAGES_VIEW_H
 3  
 4 #include <QFutureWatcher>
 5 #include <QWidget>
 6  
 7 class QLabel;
 8 class QPushButton;
 9 class QVBoxLayout;
10 class QGridLayout;
11  
12 class ImagesView : public QWidget
13 {
14     Q_OBJECT
15  
16 public:
17     explicit ImagesView(QWidget *parent = 0);
18     ~ImagesView();
19  
20 private slots:
21     void open();  // 打开目录，加载图片
22     void showImage(int index);  // 显示图片
23     void finished();  // 更新按钮状态
24  
25 private:
26     QPushButton *m_pOpenButton;
27     QPushButton *m_pCancelButton;
28     QPushButton *m_pPauseButton;
29     QVBoxLayout *m_pMainLayout;
30     QGridLayout *m_pImagesLayout;
31     QList<QLabel *> labels;
32     QFutureWatcher<QImage> *m_pWatcher;
33 };
34  
35 #endif // IMAGES_VIEW_H
```

下面是实现部分，c_nImageSize 表示的是图片被缩放的大小（宽度：100 px，高度：100px），函数 scale() 则是对图片缩放的具体实现。

ImagesView.cpp

```
  1 #include <QLabel>
  2 #include <QPushButton>
  3 #include <QProgressBar>
  4 #include <QFileDialog>
  5 #include <QtConcurrent/QtConcurrentMap>
  6 #include <QStandardPaths>
  7 #include <QHBoxLayout>
  8 #include <qmath.h>
  9 #include "ImagesView.h"
 10  
 11 const int c_nImageSize = 100;
 12  
 13 // 缩放图片
 14 QImage scale(const QString &imageFileName)
 15 {
 16     QImage image(imageFileName);
 17     return image.scaled(QSize(c_nImageSize, c_nImageSize), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
 18 }
 19  
 20 ImagesView::ImagesView(QWidget *parent)
 21     : QWidget(parent)
 22 {
 23     setWindowIcon(QIcon(":/Images/logo"));
 24     setWindowTitle(QStringLiteral("Qt之QFutureWatcher"));
 25     resize(800, 600);
 26  
 27     // 初始化控件
 28     m_pWatcher = new QFutureWatcher<QImage>(this);
 29     m_pOpenButton = new QPushButton(QStringLiteral("打开图片"));
 30     m_pCancelButton = new QPushButton(QStringLiteral("取消"));
 31     m_pPauseButton = new QPushButton(QStringLiteral("暂停/恢复"));
 32     QProgressBar *pProgressBar = new QProgressBar(this);
 33  
 34     m_pCancelButton->setEnabled(false);
 35     m_pPauseButton->setEnabled(false);
 36  
 37     // 布局
 38     QHBoxLayout *pButtonLayout = new QHBoxLayout();
 39     pButtonLayout->addWidget(m_pOpenButton);
 40     pButtonLayout->addWidget(m_pCancelButton);
 41     pButtonLayout->addWidget(m_pPauseButton);
 42     pButtonLayout->addStretch();
 43     pButtonLayout->setSpacing(10);
 44     pButtonLayout->setMargin(0);
 45  
 46     m_pImagesLayout = new QGridLayout();
 47  
 48     m_pMainLayout = new QVBoxLayout();
 49     m_pMainLayout->addLayout(pButtonLayout);
 50     m_pMainLayout->addWidget(pProgressBar);
 51     m_pMainLayout->addLayout(m_pImagesLayout);
 52     m_pMainLayout->addStretch();
 53     m_pMainLayout->setSpacing(10);
 54     m_pMainLayout->setContentsMargins(10, 10, 10, 10);
 55     setLayout(m_pMainLayout);
 56  
 57     // 连接信号槽 - 加载、显示进度、打开、取消等操作
 58     connect(m_pWatcher, SIGNAL(resultReadyAt(int)), SLOT(showImage(int)));
 59     connect(m_pWatcher, SIGNAL(progressRangeChanged(int,int)), pProgressBar, SLOT(setRange(int,int)));
 60     connect(m_pWatcher, SIGNAL(progressValueChanged(int)), pProgressBar, SLOT(setValue(int)));
 61     connect(m_pWatcher, SIGNAL(finished()), SLOT(finished()));
 62     connect(m_pOpenButton, SIGNAL(clicked()), SLOT(open()));
 63     connect(m_pCancelButton, SIGNAL(clicked()), m_pWatcher, SLOT(cancel()));
 64     connect(m_pPauseButton, SIGNAL(clicked()), m_pWatcher, SLOT(togglePaused()));
 65 }
 66  
 67 ImagesView::~ImagesView()
 68 {
 69     m_pWatcher->cancel();
 70     m_pWatcher->waitForFinished();
 71 }
 72  
 73 // 打开目录，加载图片
 74 void ImagesView::open()
 75 {
 76     // 如果已经加载图片，取消并进行等待
 77     if (m_pWatcher->isRunning()) {
 78         m_pWatcher->cancel();
 79         m_pWatcher->waitForFinished();
 80     }
 81  
 82     // 显示一个文件打开对话框
 83     QStringList files = QFileDialog::getOpenFileNames(this,
 84                                                       QStringLiteral("选择图片"),
 85                                                       QStandardPaths::writableLocation(QStandardPaths::PicturesLocation),
 86                                                       "*.jpg *.png");
 87  
 88     if (files.count() == 0)
 89         return;
 90  
 91     // 做一个简单的布局
 92     qDeleteAll(labels);
 93     labels.clear();
 94  
 95     int dim = qSqrt(qreal(files.count())) + 1;
 96     for (int i = 0; i < dim; ++i) {
 97         for (int j = 0; j < dim; ++j) {
 98             QLabel *pLabel = new QLabel(this);
 99             pLabel->setFixedSize(c_nImageSize, c_nImageSize);
100             m_pImagesLayout->addWidget(pLabel, i, j);
101             labels.append(pLabel);
102         }
103     }
104  
105     // 使用 mapped 来为 files 运行线程安全的 scale 函数
106     m_pWatcher->setFuture(QtConcurrent::mapped(files, scale));
107  
108     m_pOpenButton->setEnabled(false);
109     m_pCancelButton->setEnabled(true);
110     m_pPauseButton->setEnabled(true);
111 }
112  
113 // 显示图片
114 void ImagesView::showImage(int index)
115 {
116     labels[index]->setPixmap(QPixmap::fromImage(m_pWatcher->resultAt(index)));
117 }
118  
119 // 更新按钮状态
120 void ImagesView::finished()
121 {
122     m_pOpenButton->setEnabled(true);
123     m_pCancelButton->setEnabled(false);
124     m_pPauseButton->setEnabled(false);
125 }
```

构造函数中，需要注意的是槽函数，其中 resultReadyAt() 表示 index 对应位置的处理结果已准备就绪，所以连接该信号至槽函数 showImage()，可以显示处理完的图片。

为了显示处理进度，我们构造了一个进度条，当 QFutureWatcher 的 progressRangeChanged() 的信号发射时，进度条的范围会发生改变，而 progressValueChanged() 信号发射时，会更新进度条的值。

如果加载的图片较多时，可以通过点击“取消”按钮，这时会调用 QFutureWatcher 的 cancel() 槽函数来取消计算。“暂停/恢复”则调用 togglePaused() 槽函数，用于切换异步计算的暂停状态，换句话说，如果计算当前已暂停，调用此函数将进行恢复；如果计算正在运行，则会暂停。

当点击“打开”按钮时，会调用槽函数 open()，默认打开图片目录，以便进行图片的选择。然后根据图片创建对应数量的标签 QLabel，用于显示后期缩放的图片。创建完成后，使用 mapped() 进行并行计算，并添加至 QFutureWatcher 中，让其使用信号和槽监视 QFuture。

接下来，就可以直接使用了。

```
 1 #include <QApplication>
 2 #include "ImagesView.h"
 3  
 4 int main(int argc, char *argv[])
 5 {
 6     QApplication app(argc,argv);
 7  
 8     ImagesView view;
 9     view.show();
10  
11     return app.exec();
12 }
```

这样，我们就完成了一个图片缩放加载缩放的功能。

原文作者：十年编程老舅

原文地址：http://t.csdn.cn/Vjnq5



# 【NO.57】、Qt QTimerEvent 定时器事件

QTimerEvent类用来描述一个定时器事件。starttimer开启一个定时器，传入一个参数为超时时间，毫秒为单位。返回值是一个timerid，在timerEvent事件函数中，根据timerid来实现超时函数。

## 1、MainWindow.h

```
 1 #ifndef MAINWINDOW_H
 2 #define MAINWINDOW_H
 3  
 4 #include <QMainWindow>
 5 #include <QTimerEvent>
 6 namespace Ui {
 7 class MainWindow;
 8 }
 9  
10 class MainWindow : public QMainWindow
11 {
12     Q_OBJECT
13  
14 public:
15     explicit MainWindow(QWidget *parent = 0);
16     ~MainWindow();
17 protected:
18     void timerEvent(QTimerEvent* event);
19  
20 private:
21     Ui::MainWindow *ui;
22     int id1;
23     int id2;
24     int id3;
25 };
26  
27 #endif // MAINWINDOW_H
```

## 2、mainwindow.cpp

```
 1 #include "mainwindow.h"
 2 #include "ui_mainwindow.h"
 3 #include <QDebug>
 4 MainWindow::MainWindow(QWidget *parent) :
 5     QMainWindow(parent),
 6     ui(new Ui::MainWindow)
 7 {
 8     ui->setupUi(this);
 9     id1 = startTimer(1000);//开启一个1秒定时器，返回其ID
10     id2 = startTimer(1500);
11     id3 = startTimer(2200);
12 }
13  
14 MainWindow::~MainWindow()
15 {
16     delete ui;
17 }
18  
19 void MainWindow::timerEvent(QTimerEvent *event)
20 {
21     if(event->timerId() == id1)
22     {
23         qDebug()<<"timer1";
24     }
25     else if(event->timerId() == id2)
26     {
27         qDebug()<<"timer2";
28     }
29     else
30     {
31         qDebug()<<"timer3";
32     }
33 }
```

原文作者：十年编程老舅

原文地址：http://t.csdn.cn/UT49i



# 【NO.58】、Qt QWaitCondition 的正确使用方法

## 1、简单用法

QWaitCondition 用于多线程的同步，一个线程调用QWaitCondition::wait() 阻塞等待，直到另一个线程调用QWaitCondition::wake() 唤醒才继续往下执行。

为了描述方便，这里假设主线程调用Send()往通信口发送一个数据包，然后阻塞等待回包才继续往下执行。另一个线程（通信线程）不断从通信口中接收数据并解析成数据包，然后唤醒主线程。下面是按网上给的最简单的方法：

```
 1 // 示例一
 2 
 3 // 主线程
 4 Send(&packet);
 5 mutex.lock();
 6 condition.wait(&mutex); 
 7 if (m_receivedPacket)
 8 {
 9     HandlePacket(m_receivedPacket); // 另一线程传来回包
10 }
11 mutex.unlock();
12 
13 
14 // 通信线程
15 m_receivedPacket = ParsePacket(buffer);  // 将接收的数据解析成包
16 condition.wakeAll();
```

通常情况下，上述代码能跑得很好。但在某些特殊情况下，可能会出现混乱，大大降低通信可靠性。

在主线程中，调用 Send(&packet) 发送后，假如通信线程立即收到回包，在主线程还来不及调用 wait() 的时候，已经先 wakeAll() 了，显然这次唤醒是无效的，但主线程继续调用 wait()，然后一直阻塞在那里，因为该回的包已经回了。经测试出现这种现象的概率还是挺大的，因为我们不敢保证主线程总会被优先调度。即使主线程已经调用了 wait()，也不能保证底层操作系统的 wait_block 系统调用先于 wake 系统调用，毕竟wait() 函数也是层层封装的。

## 2、严谨用法

QWaitCondition::wait() 在使用时必须传入一个上锁的 QMutex 对象。这是很有必要的。而上述示例一代码中，我们虽然用了 mutex，但只是为了形式上传入QMutex参数，让编译器能正常编译而已，事实上，没有其它任何线程再用到这个mutex。而 mutex 本来就是让多个线程能协调工作的，所以上述示例一主线程用的 mutex 是无效的。

根据 Qt 手册，wait() 函数必须传入一个已上锁的 mutex 对象，在 wait() 执行过程中，mutex一直保持上锁状态，直到调用操作系统的wait_block 在阻塞的一瞬间把 mutex 解锁（严格说来应该是原子操作，即系统能保证在真正执行阻塞等待指令时才解锁）。另一线程唤醒后，wait() 函数将在第一时间重新给 mutex 上锁（这种操作也是原子的），直到显示调用 mutex.unlock() 解锁。

在通信线程也用上 mutex 后，整个通信时序正常了，完全解决了示例一的问题。代码如下：

```
 1 // 示例二
 2 
 3 // 主线程
 4 mutex.lock();
 5 Send(&packet);
 6 condition.wait(&mutex); 
 7 if (m_receivedPacket)
 8 {
 9     HandlePacket(m_receivedPacket); // 另一线程传来回包
10 }
11 mutex.unlock();
12 
13 
14 // 通信线程
15 m_receivedPacket = ParsePacket(buffer);  // 将接收的数据解析成包
16 mutex.lock();
17 condition.wakeAll();
18 mutex.unlock();
```

上述示例二中，主线程先把 mutex 锁占据，即从发送数据包开始，一直到 QWaitCondition::wait() 在操作系统层次真正执行阻塞等待指令，这一段主线程的时间段内，mutex 一直被上锁，即使通信线程很快就接收到数据包，也不会直接调用 wakeAll()，而是在调用 mutex.lock() 时阻塞住（因为主线程已经把mutex占据上锁了，再尝试上锁就会被阻塞），直到主线程 QWaitCondition::wait() 真正执行操作系统的阻塞等待指令并释放mutex，通信线程的 mutex.lock() 才即出阻塞，继续往下执行，调用 wakeAll()，此时一定能唤醒主线程成功。

由此可见，通过 mutex 把有严格时序要求的代码保护起来，同时把 wakeAll() 也用同一个 mutex 保护起来，这样能保证：一定先有 wait() ，再有 wakeAll()，不管什么情况，都能保证这种先后关系，而不至于摆乌龙。

推而广之：

mutex 和 condition 联合使用是多线程中的一个常用的设计模式，不仅是 Qt，对于 C++ 的 std::condition_variable 和 std::mutex ，以及 java 的 synchronized / wait / notify 也都适用。

原文作者：十年编程老舅

原文地址：Qt QWaitCondition 的正确使用方法



# 【NO.59】、PyQt5高级界面控件之QTableWidget

前言

QTableWidget是Qt程序中常用的显示数据表格的控件，类似于c#中的DataGrid。QTableWidget是QTableView的子类，它使用标准的数据模型，并且其单元数据是通过QTableWidgetItem对象来实现的，使用QTableWidget时就需要QTableWidgetItem。用来表示表格中的一个单元格，整个表格就是用各个单元格构建起来的

## 1、QTableWidget类中的常用方法

| 方法                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| setRowCount(int row)                                         | 设置QTableWidget表格控件的行数                               |
| setColumnCount(int col)                                      | 设置QTableWidget表格控件的列数                               |
| setHorizontalHeaderLabels()                                  | 设置QTableWidget表格控件的水平标签                           |
| setVerticalHeaderLabels()                                    | 设置QTableWidget表格控件的垂直标签                           |
| setItem(int ,int ,QTableWidgetItem)                          | 在QTableWidget表格控件的每个选项的单元控件内添加控件         |
| horizontalHeader()                                           | 获得QTableWidget表格控件的表格头，以便执行隐藏               |
| rowCount()                                                   | 获得QTableWidget表格控件的行数                               |
| columnCount()                                                | 获得QTableWidget表格控件的列数                               |
| setEditTriggers(EditTriggers triggers)                       | 设置表格是否可以编辑，设置表格的枚举值                       |
| setSelectionBehavior                                         | 设置表格的选择行为                                           |
| setTextAlignment()                                           | 设置单元格内文本的对齐方式                                   |
| setSpan(int row,int column,int rowSpanCount,int columnSpanCount) | 合并单元格，要改变单元格的第row行，column列，要合并rowSpancount行数和columnSpanCount列数 |
|                                                              | row：要改变的行数                                            |
|                                                              | column：要改变的列数                                         |
|                                                              | rowSpanCount：需要合并的行数                                 |
|                                                              | columnSpanCount：需要合并的列数                              |
| setShowGrid()                                                | 在默认情况下表格的显示是有网格的，可以设置True或False用于是否显示，默认True |
| setColumnWidth(int column,int width)                         | 设置单元格行的宽度                                           |
| setRowHeight(int row,int height)                             | 设置单元格列的高度                                           |

## 2、编辑规则的枚举值类型

| 选项                                       | 值   | 描述                         |
| ------------------------------------------ | ---- | ---------------------------- |
| QAbstractItemView.NoEditTriggers0No        | 0    | 不能对表格内容进行修改       |
| QAbstractItemView.CurrentChanged1Editing   | 1    | 任何时候都能对单元格进行修改 |
| QAbstractItemView.DoubleClicked2Editing    | 2    | 双击单元格                   |
| QAbstractItemView.SelectedClicked4Editing  | 4    | 单击已经选中的内容           |
| QAbstractItemView.EditKeyPressed8Editing   | 8    | 当修改键按下时修改单元格     |
| QAbstractItemView.AnyKeyPressed16Editing   | 16   | 按任意键修改单元格           |
| QAbstractItemView.AllEditTriggers31Editing | 31   | 包括以上所有条件             |

## 3、表格选择行为的枚举值

| 选择                                      | 值   | 描述           |
| ----------------------------------------- | ---- | -------------- |
| QAbstractItemView.SelectItems0Selecting   | 0    | 选中单个单元格 |
| QAbstractItemView.SelectRows1Selecting    | 1    | 选中一行       |
| QAbstractItemView.SelectColumns2Selecting | 2    | 选中一列       |

## 4、单元格文本水平对齐方式

| 选项            | 描述                                 |
| --------------- | ------------------------------------ |
| Qt.AlignLeft    | 将单元格内的内容沿单元格的左边缘对齐 |
| Qt.AlignRight   | 将单元格内的内容沿单元格的右边缘对齐 |
| Qt.AlignHCenter | 在可用空间中，居中显示在水平方向上   |
| Qt.AlignJustify | 将文本在可用空间内对齐，默认从左到右 |

## 5、单元格文本垂直对齐方式

| 选项             | 描述                               |
| ---------------- | ---------------------------------- |
| Qt.AlignTop      | 与顶部对齐                         |
| Qt.AlignBottom   | 与底部对齐                         |
| Qt.AlignVCenter  | 在可用空间中，居中显示在垂直方向上 |
| Qt.AlignBaseline | 与基线对齐                         |

如果要设置水平和垂直方向对齐方式，比如在表格空间内上下，左右居中对齐，那么只要使用Qt,AlignHCenter和Qt,AlignVCenter即可

## 6、实例一：QTableWidget的基本用法

```
import sys
from PyQt5.QtWidgets import *

class Table(QWidget):
    def __init__(self):
        super(Table, self).__init__()
        self.initUI()
    def initUI(self):
        self.setWindowTitle("QTableWidget例子")
        self.resize(400,300)
        layout=QHBoxLayout()

        #实现的效果是一样的，四行三列，所以要灵活运用函数，这里只是示范一下如何单独设置行列
        TableWidget=QTableWidget(4,3)

        # TableWidget = QTableWidget()
        # TableWidget.setRowCount(4)
        # TableWidget.setColumnCount(3)



        #设置水平方向的表头标签与垂直方向上的表头标签，注意必须在初始化行列之后进行，否则，没有效果
        TableWidget.setHorizontalHeaderLabels(['姓名','性别','体重（kg）'])
        #Todo 优化1 设置垂直方向的表头标签
        #TableWidget.setVerticalHeaderLabels(['行1', '行2', '行3', '行4'])

        #TODO 优化 2 设置水平方向表格为自适应的伸缩模式
        ##TableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        #TODO 优化3 将表格变为禁止编辑
        #TableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)

        #TODO 优化 4 设置表格整行选中
        #TableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)

        #TODO 优化 5 将行与列的高度设置为所显示的内容的宽度高度匹配
        #QTableWidget.resizeColumnsToContents(TableWidget)
        #QTableWidget.resizeRowsToContents(TableWidget)

        #TODO 优化 6 表格头的显示与隐藏
        #TableWidget.verticalHeader().setVisible(False)
        #TableWidget.horizontalHeader().setVisible(False)

        #TOdo 优化7 在单元格内放置控件
        # comBox=QComboBox()
        # comBox.addItems(['男','女'])
        # comBox.addItem('未知')
        # comBox.setStyleSheet('QComboBox{margin:3px}')
        # TableWidget.setCellWidget(0,1,comBox)
        #
        # searchBtn=QPushButton('修改')
        # searchBtn.setDown(True)
        # searchBtn.setStyleSheet('QPushButton{margin:3px}')
        # TableWidget.setCellWidget(0,2,searchBtn)


        #添加数据
        newItem=QTableWidgetItem('张三')
        TableWidget.setItem(0,0,newItem)

        newItem=QTableWidgetItem('男')
        TableWidget.setItem(0,1,newItem)

        newItem=QTableWidgetItem('160')
        TableWidget.setItem(0,2,newItem)

        layout.addWidget(TableWidget)

        self.setLayout(layout)
if __name__ == '__main__':
    app=QApplication(sys.argv)
    win=Table()
    win.show()
    sys.exit(app.exec_())
```

初始运行程序，显示效果如下

![image-20221214203719201](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203719201.png)

代码分析

构造一个QTableWidget对象，设置表格为4行3列

```
TableWidget=QTableWidget(4,3)
```

设置表格头

```
TableWidget.setHorizontalHeaderLabels(['姓名','性别','体重（kg）'])
```

生成一个QTableWidgetItem对象，并添加到表格的0行0列处

```
 newItem=QTableWidgetItem('张三')
 TableWidget.setItem(0,0,newItem)
```

**优化1**:设置垂直方向表格头标签

```
TableWidget.setVerticalHeaderLabels(['行1', '行2', '行3', '行4'])
```

效果如下

![image-20221214203753813](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203753813.png)

**优化2**：设置表格头为伸缩模式 使用QTableWidget对象的horizontalHeader（）函数，设置表格为自适应的伸缩模式，即可根据窗口的大小来改变网格的大小

```
TableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
```

![image-20221214203800284](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203800284.png)

**优化3**：将表格设置为禁止编辑 在默认情况下，表格中的字符是可以更改的，比如双击一个单元格，就可以修改原来的内容，如果想禁止这种操作，让表格对用户只是只读，则可以编辑一下代码

```
TableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)
```

![image-20221214203807125](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203807125.png)

**优化4**：表格整行选中 表格默认选择的是单个单元格，通过以下代码可以设置整行选中

```
 TableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)
```

![image-20221214203813502](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203813502.png)

**优化5**：将行与列的宽度高度与文本内容的宽高相匹配

```
QTableWidget.resizeColumnsToContents(TableWidget)
QTableWidget.resizeRowsToContents(TableWidget)
```

![image-20221214203820352](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203820352.png)

**优化6**：表格头的显示与隐藏

```
TableWidget.verticalHeader().setVisible(False)
TableWidget.horizontalHeader().setVisible(False)
```

![image-20221214203827549](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203827549.png)

**优化7**：在单元格内放置控件 QTableWidget不仅允许往单元格内放置文字，还允许放置控件，通过QTableWidget.setItem()来添加PyQt的基本控件 这里把一个下拉列表框和一个按钮加入单元格中，设置控件与单元格的边距，如为3px像素，代码如下

```
 		comBox=QComboBox()
        comBox.addItems(['男','女'])
        comBox.addItem('未知')
        comBox.setStyleSheet('QComboBox{margin:3px}')
        TableWidget.setCellWidget(0,1,comBox)

        searchBtn=QPushButton('修改')
        searchBtn.setDown(True)
        searchBtn.setStyleSheet('QPushButton{margin:3px}')
        TableWidget.setCellWidget(0,2,searchBtn)
```

![image-20221214203834885](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203834885.png)

## 7、实例二：在表格中快速定位到指定行

```
import sys
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *

class Table(QWidget):
    def __init__(self):
        super(Table, self).__init__()
        self.initUI()
    def initUI(self):
        #设置标题与初始大小
        self.setWindowTitle('QTableWidget例子')
        self.resize(600,800)

        ##水平布局
        layout=QHBoxLayout()
        #实例化表格视图（30*4）
        tablewidget=QTableWidget(30,4)
        layout.addWidget(tablewidget)

        for i in range(30):
            for j in range(4):
                itemContent='(%d,%d)'%(i,j)
                #为每个表格内添加数据
                tablewidget.setItem(i,j,QTableWidgetItem(itemContent))

        self.setLayout(layout)

        #遍历表格查找对应项
        text='(10,1)'
        items=tablewidget.findItems(text,Qt.MatchExactly)
        item=items[0]
        #选中单元格
        item.setSelected(True)
        #设置单元格的背脊颜色为红
        item.setForeground(QBrush(QColor(255,0,0)))

        row=item.row()
        #通过鼠标滚轮定位，快速定位到第十一行
        tablewidget.verticalScrollBar().setSliderPosition(row)
if __name__ == '__main__':
    app=QApplication(sys.argv)
    table=Table()
    table.show()
    sys.exit(app.exec_())
```

效果如图

![image-20221214203846594](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203846594.png)

## 8、实例三：QTableWidget的高级用法

```
import sys
from PyQt5.QtWidgets import (QWidget, QTableWidget, QHBoxLayout, QApplication, QTableWidgetItem)
from PyQt5.QtGui import QBrush, QColor, QFont
from PyQt5.QtCore import Qt


class Table(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        #设置标题与初始大小
        self.setWindowTitle("QTableWidget 例子")
        self.resize(430, 230)

        #水平布局，初始表格为（4*3），添加到布局中
        conLayout = QHBoxLayout()
        tableWidget = QTableWidget(5,3)
        conLayout.addWidget(tableWidget)

        #设置水平头标签
        tableWidget.setHorizontalHeaderLabels(['姓名', '性别', '体重(kg)'])

        #创建新条目，设置背景颜色，添加到表格指定行列中
        newItem = QTableWidgetItem("张三")
        #newItem.setForeground(QBrush(QColor(255, 0, 0)))
        tableWidget.setItem(0, 0, newItem)

        # 创建新条目，设置背景颜色，添加到表格指定行列中
        newItem = QTableWidgetItem("男")
        #newItem.setForeground(QBrush(QColor(255, 0, 0)))
        tableWidget.setItem(0, 1, newItem)

        # 创建新条目，设置背景颜色，添加到表格指定行列中
        newItem = QTableWidgetItem("160")
        #newItem.setForeground(QBrush(QColor(255, 0, 0)))
        tableWidget.setItem(0, 2, newItem)

        # newItem = QTableWidgetItem("李四")
        # #将字体加粗，黑色字体
        # newItem.setFont(QFont('Times',12,QFont.Black))
        # tableWidget.setItem(1, 0, newItem)
        #
        # # 创建新条目，设置背景颜色，添加到表格指定行列中
        # newItem = QTableWidgetItem("男")
        # newItem.setFont(QFont('Times', 12, QFont.Black))
        # tableWidget.setItem(1, 1, newItem)
        #
        # # 创建新条目，设置背景颜色，添加到表格指定行列中
        # newItem = QTableWidgetItem("150")
        # newItem.setFont(QFont('Times', 12, QFont.Black))
        # tableWidget.setItem(1, 2, newItem)
        #
        # newItem = QTableWidgetItem("王五")
        # #将字体加粗，黑色字体
        # newItem.setFont(QFont('Times',12,QFont.Black))
        # tableWidget.setItem(2, 0, newItem)
        #
        # # 创建新条目，设置背景颜色，添加到表格指定行列中
        # newItem = QTableWidgetItem("女")
        # newItem.setFont(QFont('Times', 12, QFont.Black))
        # tableWidget.setItem(2, 1, newItem)
        #
        # # 创建新条目，设置背景颜色，添加到表格指定行列中
        # newItem = QTableWidgetItem("175")
        # newItem.setFont(QFont('Times', 12, QFont.Black))

        # 设置单元格文本的对齐方式
        #newItem.setTextAlignment(Qt.AlignRight|Qt.AlignBottom)
        #tableWidget.setItem(2, 2, newItem)


        #按照体重排序
        #Qt.DescendingOrder降序
        #Qt.AscEndingOrder升序
        #tableWidget.sortItems(2,Qt.DescendingOrder)

        #合并单元格
        #tableWidget.setSpan(2,0,4,1)

        #设置单元格的大小
        #将第一列的单元宽度设置为150
        #tableWidget.setColumnWidth(0,150)
        #将第一行的单元格高度的设置为120
        #tableWidget.setRowHeight(0,120)


        #表格中不显示分割线
        #tableWidget.setShowGrid(False)

        #隐藏垂直头标签
        #tableWidget.verticalHeader().setVisible(False)




        self.setLayout(conLayout)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    example = Table()
    example.show()
    sys.exit(app.exec_())
```

初始运行，效果如下

![image-20221214203855148](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203855148.png)

**优化1**：设置单元格的文本颜色，将第一行中的三个文本颜色设置为红色

```
newItem.setForeground(QBrush(QColor(255, 0, 0)))
```

**优化2**：将字体加粗

```
#设置字体类型，大小号，颜色
newItem.setFont(QFont('Times',12,QFont.Black))
```

![image-20221214203901981](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203901981.png)

**优化3**：设置单元格的排序方式

```
from PyQt5.QtCore import Qt
#按照体重排序
#Qt.DescendingOrder降序
#Qt.AscEndingOrder升序
tableWidget.sortItems(2,Qt.DescendingOrder)
```

![image-20221214203908585](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203908585.png)

**优化4**：单元格的文本对齐方式 这里更改了王五体重的文本对齐方式为右下角处

```
 		# 设置单元格文本的对齐方式(右下)
        newItem.setTextAlignment(Qt.AlignRight|Qt.AlignBottom)
        tableWidget.setItem(2, 2, newItem)
```

![image-20221214203917103](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203917103.png)

**优化5**：合并单元格 将表格中第一行第一列的单元格，更改为占据5行1列

```
#合并单元格
tableWidget.setSpan(2,0,5,1)
```

![image-20221214203924351](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203924351.png)

**优化6**：设置单元格的大小 这里将第一行宽度设置为150，高度设置为120

```
#将第一列的单元宽度设置为150
tableWidget.setColumnWidth(0,150)
#将第一行的单元格高度的设置为120
tableWidget.setRowHeight(0,120)
```

![image-20221214203930689](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203930689.png)

**优化7**：在表格中不显示分割线 QTableWidget类的setShowGrid（）函数是从QTableView类继承的，用来设置是否显示表格的分割线，默认显示分割线

```
 #表格中不显示分割线
tableWidget.setShowGrid(False)
```

![image-20221214203937667](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203937667.png)

**优化8**：为单元格添加图片 还可以在单元格内添加图片并显示图片描述信息，代码如下 这里图片放置在王五体重的单元格内

```
#添加图片
newItem = QTableWidgetItem(QIcon("./images/bao1.png"), "背包")
tableWidget.setItem(2, 2, newItem)
```

![image-20221214203944194](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203944194.png)

## 9、实例四：单元格内图片的显示

```
import sys
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore  import *

class Table(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        #设置标题与初始大小
        self.setWindowTitle("QTableWidget 例子")
        self.resize(1000 ,900);
        #设置布局，初始表格5*3
        conLayout = QHBoxLayout()
        table= QTableWidget(5,3)

        #设置表格水平头标签
        table.setHorizontalHeaderLabels(['图片1' ,'图片2' ,'图片3'])
        #设置不可编辑模式
        table.setEditTriggers( QAbstractItemView.NoEditTriggers)
        #设置图片的大小
        table.setIconSize(QSize(300 ,200))

        #设置所有行列宽高数值与图片大小相同
        for i in range(3):   # 让列宽和图片相同
            table.setColumnWidth(i , 300)
        for i in range(5):   # 让行高和图片相同
            table.setRowHeight(i , 200)

        for k in range(15):
            i = k/ 3
            j = k % 3

            #实例化表格窗口条目
            item = QTableWidgetItem()
            #用户点击表格时，图片被选中
            item.setFlags(Qt.ItemIsEnabled)
            #图片路径设置与图片加载
            icon = QIcon(r'.\images\bao%d.png' % k)
            item.setIcon(QIcon(icon))
            #输出当前进行的条目序号
            print('e/icons/%d.png i=%d j=%d' % (k, i, j))
            #将条目加载到相应行列中
            table.setItem(i, j, item)


        conLayout.addWidget(table)
        self.setLayout(conLayout)



if __name__ == '__main__':
    app = QApplication(sys.argv)
    example = Table()
    example.show()
    sys.exit(app.exec_())
```

效果如下

![image-20221214203956601](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214203956601.png)

## 10、实例五：支持右键菜单

```
import sys
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *


class Table(QWidget):
    def __init__(self):
        super(Table, self).__init__()
        self.initUI()

    def initUI(self):
        # 设置标题与初始大小
        self.setWindowTitle('QTableWidget demo')
        self.resize(500, 300)

        # 水平布局，初始表格5*3，添加到布局
        layout = QHBoxLayout()
        self.tableWidget = QTableWidget(5, 3)
        layout.addWidget(self.tableWidget)

        # 设置表格水平方向的头标签
        self.tableWidget.setHorizontalHeaderLabels([ '姓名', '性别', '体重' ])

        # 设置水平方向自动伸缩填满窗口
        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        # 添加数据到指定行列
        newItem = QTableWidgetItem("张三")
        self.tableWidget.setItem(0, 0, newItem)

        newItem = QTableWidgetItem("男")
        self.tableWidget.setItem(0, 1, newItem)

        newItem = QTableWidgetItem("160")
        self.tableWidget.setItem(0, 2, newItem)

        newItem = QTableWidgetItem("李四")
        self.tableWidget.setItem(1, 0, newItem)

        newItem = QTableWidgetItem("女")
        self.tableWidget.setItem(1, 1, newItem)

        newItem = QTableWidgetItem("120")
        self.tableWidget.setItem(1, 2, newItem)

        # 允许右键产生菜单
        self.tableWidget.setContextMenuPolicy(Qt.CustomContextMenu)
        # 将右键菜单绑定到槽函数generateMenu
        self.tableWidget.customContextMenuRequested.connect(self.generateMenu)

        self.setLayout(layout)

    def generateMenu(self, pos):
        # 计算有多少条数据，默认-1,
        row_num = -1
        for i in self.tableWidget.selectionModel().selection().indexes():
            row_num = i.row()

        # 表格中只有两条有效数据，所以只在前两行支持右键弹出菜单
        if row_num < 2:
            menu = QMenu()
            item1 = menu.addAction(u'选项一')
            item2 = menu.addAction(u'选项二')
            item3 = menu.addAction(u'选项三')
            action = menu.exec_(self.tableWidget.mapToGlobal(pos))
            # 显示选中行的数据文本
            if action == item1:
                print('你选了选项一，当前行文字内容是：', self.tableWidget.item(row_num, 0).text(),
                      self.tableWidget.item(row_num, 1).text(),
                      self.tableWidget.item(row_num, 2).text())
            if action == item2:
                print('你选了选项二，当前行文字内容是：', self.tableWidget.item(row_num, 0).text(),
                      self.tableWidget.item(row_num, 1).text(),
                      self.tableWidget.item(row_num, 2).text())
            if action == item3:
                print('你选了选项三，当前行文字内容是：', self.tableWidget.item(row_num, 0).text(),
                      self.tableWidget.item(row_num, 1).text(),
                      self.tableWidget.item(row_num, 2).text())


if __name__ == '__main__':
    app = QApplication(sys.argv)
    example = Table()
    example.show()
    sys.exit(app.exec_())
```

![image-20221214204007683](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221214204007683.png)

原文作者：音视频开发老舅

原文地址：http://t.csdn.cn/H4oxn



# 【NO.60】、qmake：高级用法

## 1、添加新的配置特性

特性（**features**）是 ***.prf** 文件中自定义函数和定义的集合（Qt安装目录\mkspecs\features 中有很多 *.prf文件）。

存放特性文件的目录有很多地方，qmake 在查找 .prf 文件时会按以下顺序检查每个目录：

- 在 **QMAKEFEATURES** 环境变量中列出的目录中，
- 在 **QMAKEFEATURES** 属性变量中列出的目录中。
- 在位于 mkspecs 目录中的 features 目录中。
- 在 **QMAKESPEC** 环境变量提供的目录下的 features 目录中。
- 在 data_install/mkspecs 目录中的 features 目录中。
- 在作为 **QMAKSPEC** 环境变量指定的目录的同级存在的 features 目录中。

然后在以下子目录中搜索功能文件：

- features/unix、features/win32、features/macx，取决于使用的平台
- features/

例如以下配置：

```
 CONFIG += myfeatures
```

添加到 **CONFIG** 变量后，qmake 将在完成解析项目文件后搜索上面列出的位置以查找 **myfeatures.prf** 文件。在 Unix 系统上将查找以下文件：

- $**QMAKEFEATURES**/myfeatures.prf
- $$**QMAKEFEATURES**/myfeatures.prf
- myfeatures.prf（在项目的根目录中）。项目根由顶级 ***.pro** 文件确定。
- QMAKEPATH/mkspecs/features/unix/myfeatures.prf、QMAKEPATH/mkspecs/features/myfeatures.prf
- QMAKESPEC/features/unix/myfeatures.prf、QMAKESPEC/features/myfeatures.prf
- data_install/mkspecs/features/unix/myfeatures.prf 和 data_install/mkspecs/features/myfeatures.prf
- QMAKESPEC/../features/unix/myfeatures.prf、QMAKESPEC/../features/myfeatures.prf

注意：*.prf 文件的名称必须为小写。

## 2、安装文件

在 Unix 上经常使用构建工具来安装应用程序和库，例如通过调用 **make install**。qmake 有一个安装集的概念。例如，可以通过以下方式描述文档文件的集合：

```
 documentation.path = /usr/local/program/doc
 documentation.files = docs/*
```

- **path成员：**通知qmake文件应该安装在/usr/local/program/doc
- **files成员：**指定应该复制到安装目录的文件。这里 docs 目录中的所有内容都将复制到 /usr/local/program/doc。

然后将其附加到安装列表中：

```
 INSTALLS += documentation
```

qmake 将确保将指定的文件复制到安装目录。

如果将**内置安装集**附加到 **INSTALLS** 变量并且不指定文件或额外成员，qmake 将决定需要复制的内容。当前，支持 **target** 和 **dlltarget** 这两个内置安装集。例如：

```
 target.path = /usr/local/myprogram
 INSTALLS += target
```

在上面两行中，qmake 知道需要复制什么，并会自动处理安装过程。

## 3、添加自定义目标

qmake 尝试做跨平台构建工具所期望的一切。当确实需要运行特殊的**平台相关命令**时，可通过自定义目标实现。

例如：

```
 mytarget.target = .buildfile
 mytarget.commands = touch $$mytarget.target
 mytarget.depends = mytarget2

 mytarget2.commands = @echo "假装生成了mytarget2"
```

1、定义qmake要生成的名为 mytarget 的目标

2、mytarget 是名为 .buildfile 的 Makefile 文件，该目标由 touch 命令生成（Linux touch命令），即运行 mytarget.commands 指定的命令

3、mytarget 依赖于 mytarget2，即mytarget2生成之后才能生成mytarget，即运行 mytarget2.commands 指定的命令

4、最后一步是使用 **QMAKE_EXTRA_TARGETS** 变量来指示 qmake 这个对象是要构建的目标：

```
 QMAKE_EXTRA_TARGETS += mytarget mytarget2
```

这就是实际构建自定义目标所需要做的全部工作。

可能希望将这些目标绑定到 qmake 构建目标。只需将 Makefile 目标包含在 **PRE_TARGETDEPS** 列表中。

自定义目标规范支持以下成员：

- **commands**：用于生成自定义构建目标的命令。
- **CONFIG**：自定义构建目标的特定配置选项。
- **depends**：自定义构建目标所依赖的现有构建目标。
- **recurse**：指定在 Makefile 中创建规则以调用子目标特定的 Makefile 时应使用哪些子目标。
- **recurse_target**：指定应通过子目标 Makefile 为 Makefile 中的规则构建的目标。
- **target**：自定义构建目标的名称。

## 4、库依赖

通常在链接库时，qmake 依赖于底层平台来了解该库链接到哪些其他库，并让平台将它们拉入。然而，在许多情况下，这还不够。 例如，在静态链接库时，不会链接其他库，因此不会创建对这些库的依赖项。如果明确启用跟踪，qmake 会在适当的情况下尝试跟踪库的依赖项。

第一步是在库本身中启用依赖项跟踪。必须告诉 qmake 保存有关库的信息：

```
 CONFIG += create_prl
```

这仅适用于 **lib** 模板类型的工程，所有其他模板将被忽略。 启用此选项后，qmake 将创建一个以 **.prl** 结尾的文件，该文件将保存有关库的一些元信息。这个元文件就像一个普通的项目文件，但只包含内部变量声明。安装库时，通过在 **INSTALLS** 声明中将其指定为目标，qmake 会自动将 .prl 文件复制到安装路径。

第二步是在使用静态库的应用程序中启用此元信息的读取：

```
 CONFIG += link_prl
```

启用此功能后，qmake 将处理应用程序链接的所有库并找到它们的元信息。qmake 将使用它来确定相关的链接信息，特别是将值添加到应用程序项目文件的 **DEFINES** 和 **LIBS** 列表中。 一旦 qmake 处理了这个文件，它就会查看 **LIBS** 变量中新引入的库，并找到它们依赖的 .prl 文件，直到所有库都被解析为止。此时，Makefile 照常创建，并且库与应用程序显式链接。

.prl 文件应仅由 qmake 创建，不应在操作系统之间传输，因为它们可能包含平台相关信息。

原文作者：音视频开发老舅

原文地址：http://t.csdn.cn/ph9r0



# 【NO.61】、Qt事件与Windows消息循环的联系（Qt源码笔记）

QApplication注册了一个qt_internal_proc方法来处理消息循环，但是在这个方法中并没有看到一些关于Qt事件的蛛丝马迹。例如*鼠标事件*、*键盘事件*等。

其实在qt_internal_proc方法中有个调用值得注意:sendPostedEvents()。如果在我们自己Demo的鼠标事件中打个断点，不难发现，就是从这个调用来到我们的mousePressEvent()的。但是如果我们查看堆栈信息，按图索骥，会发现：

```
bool QWindowSystemInterface::sendWindowSystemEvents(QEventLoop::ProcessEventsFlags flags)
{
    int nevents = 0;
    while (QWindowSystemInterfacePrivate::windowSystemEventsQueued()) {
        QWindowSystemInterfacePrivate::WindowSystemEvent *event =
            (flags & QEventLoop::ExcludeUserInputEvents) ?
                QWindowSystemInterfacePrivate::getNonUserInputWindowSystemEvent() :
                QWindowSystemInterfacePrivate::getWindowSystemEvent();
        if (!event)
            break;
        if (QWindowSystemInterfacePrivate::eventHandler) {
            if (QWindowSystemInterfacePrivate::eventHandler->sendEvent(event))
                nevents++;
        } else {
            nevents++;
            QGuiApplicationPrivate::processWindowSystemEvent(event);
        }
        // Record the accepted state for the processed event
        // (excluding flush events). This state can then be
        // returned by flushWindowSystemEvents().
        if (event->type != QWindowSystemInterfacePrivate::FlushEvents)
            QWindowSystemInterfacePrivate::eventAccepted.store(event->eventAccepted);
        delete event;
    }
    return (nevents > 0);
}
```

在上边可以看到，这个最原始的事件就是从getXXXXXEvent()方法中得到的，而这个方法是从一个事件队列中取事件。

getWindowSystemEvent()方法中的内容是这样的：

```
QWindowSystemInterfacePrivate::WindowSystemEvent * QWindowSystemInterfacePrivate::getWindowSystemEvent()
{
    return windowSystemEventQueue.takeFirstOrReturnNull();
}
```

可以说这个事件队列就是我们要关注的焦点。那事件是如何被添加到这个队列里的，这里暂时按下不表，先记住他的名字windowSystemEventQueue。

\###从QWidget谈起  回过头来想，鼠标键盘事件其实都是依托于窗口的，但其实QApplication本身并不属于窗体，我们如果想在程序中加入一些可视的窗口，就要自己做个QWidget或者是QMainWindow等等。所以可以得出一个大概的结论，这些事件的接收处理必然和QWidget有着千丝万缕的联系。另外关于Win32消息的处理，我们必然要关注的一个，那就是回调函数。

拿着这两个线索，花了一点时间，简单梳理一下，不难发现这里边的调用。**以下调用非必要的会省略掉参数**

1. 初始化QWidget会初始化QWidgetPrivate，在QWidgetPrivate的init()中会调用QWidget::create();
2. 接着在QWidget::create()中调用QWidgetPrivate::create_sys()，在这个方法中，会创建一个QWindow，在创建之后如果QWidget是显示的，会调用QWindow::setVisible(true);
3. 在QWindow::setVisible(true)中调用QWindow::create()，这个方法中没有别的只是转调QWindowPrivate::create()

```
void QWindowPrivate::create(bool recursive)
{
    Q_Q(QWindow);
    if (platformWindow)
        return;
    if (q->parent())
        q->parent()->create();
    platformWindow = QGuiApplicationPrivate::platformIntegration()->createPlatformWindow(q);
    Q_ASSERT(platformWindow);
    if (!platformWindow) {
        qWarning() << "Failed to create platform window for" << q << "with flags" << q->flags();
        return;
    }
    QObjectList childObjects = q->children();
    for (int i = 0; i < childObjects.size(); i ++) {
        QObject *object = childObjects.at(i);
        if (!object->isWindowType())
            continue;
        QWindow *childWindow = static_cast<QWindow *>(object);
        if (recursive)
            childWindow->d_func()->create(recursive);
        // The child may have had deferred creation due to this window not being created
        // at the time setVisible was called, so we re-apply the visible state, which
        // may result in creating the child, and emitting the appropriate signals.
        if (childWindow->isVisible())
            childWindow->setVisible(true);
        if (QPlatformWindow *childPlatformWindow = childWindow->d_func()->platformWindow)
            childPlatformWindow->setParent(this->platformWindow);
    }
    QPlatformSurfaceEvent e(QPlatformSurfaceEvent::SurfaceCreated);
    QGuiApplication::sendEvent(q, &e);
}
```

4. 在这个方法中，可以看到createPlatformWindow()，顾名思义，会创建一个平台相关的*Window*。这里的实际调用是
   QWindowsIntegration::createPlatformWindow()。 而在这个方法中，我们会看到这个语句QWindowsWindowData::create(window, requested, window->title());这里的create()是一个静态方法。

5. 在create()中会搞出一个WindowCreationData，这个结构体在**qwindowswindow.cpp**中，可以看到在定义上边的注释，没错，create()中会调用
   WindowCreationData::create()来创建一个*system handle*。

```
/*!
    \class WindowCreationData
    \brief Window creation code.
    This struct gathers all information required to create a window.
    Window creation is split in 3 steps:
    \list
    \li fromWindow() Gather all required information
    \li create() Create the system handle.
    \li initialize() Post creation initialization steps.
    \endlist
    The reason for this split is to also enable changing the QWindowFlags
    by calling:
    \list
    \li fromWindow() Gather information and determine new system styles
    \li applyWindowFlags() to apply the new window system styles.
    \li initialize() Post creation initialization steps.
    \endlist
    Contains the window creation code formerly in qwidget_win.cpp.
    \sa QWindowCreationContext
    \internal
    \ingroup qt-lighthouse-win
*/
```

6. 在
   WindowCreationData::create()中会发现一个非常熟悉的一段代码 const QString windowClassName =  QWindowsContext::instance()->registerWindowClass(w);

7. 这段代码是得到一个QWindowsContext实例，调用它的registerWindowClass()方法。而在
   QWindowsContext::registerWindowClass()中，我们会看到这段代码 return registerWindowClass(cname, qWindowsWndProc, style,  GetSysColorBrush(COLOR_WINDOW),  icon);，在这里我们就会看到qWindowsWndProc，其实这个就是最终跟每个QWidget的事件相关的回调方法，这里暂时按下不表，先观察这个重载方法的内容：

```
QString QWindowsContext::registerWindowClass(QString cname,
                                             WNDPROC proc,
                                             unsigned style,
                                             HBRUSH brush,
                                             bool icon)
{
    // since multiple Qt versions can be used in one process
    // each one has to have window class names with a unique name
    // The first instance gets the unmodified name; if the class
    // has already been registered by another instance of Qt then
    // add an instance-specific ID, the address of the window proc.
    static int classExists = -1;
    const HINSTANCE appInstance = static_cast<HINSTANCE>(GetModuleHandle(0));
    if (classExists == -1) {
        WNDCLASS wcinfo;
        classExists = GetClassInfo(appInstance, reinterpret_cast<LPCWSTR>(cname.utf16()), &wcinfo);
        classExists = classExists && wcinfo.lpfnWndProc != proc;
    }
    if (classExists)
        cname += QString::number(reinterpret_cast<quintptr>(proc));
    if (d->m_registeredWindowClassNames.contains(cname))        // already registered in our list
        return cname;
#ifndef Q_OS_WINCE
    WNDCLASSEX wc;
    wc.cbSize       = sizeof(WNDCLASSEX);
#else
    WNDCLASS wc;
#endif
    wc.style        = style;
    wc.lpfnWndProc  = proc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = 0;
    wc.hInstance    = appInstance;
    wc.hCursor      = 0;
#ifndef Q_OS_WINCE
    wc.hbrBackground = brush;
    if (icon) {
        wc.hIcon = static_cast<HICON>(LoadImage(appInstance, L"IDI_ICON1", IMAGE_ICON, 0, 0, LR_DEFAULTSIZE));
        if (wc.hIcon) {
            int sw = GetSystemMetrics(SM_CXSMICON);
            int sh = GetSystemMetrics(SM_CYSMICON);
            wc.hIconSm = static_cast<HICON>(LoadImage(appInstance, L"IDI_ICON1", IMAGE_ICON, sw, sh, 0));
        } else {
            wc.hIcon = static_cast<HICON>(LoadImage(0, IDI_APPLICATION, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_SHARED));
            wc.hIconSm = 0;
        }
    } else {
        wc.hIcon    = 0;
        wc.hIconSm  = 0;
    }
#else
    if (icon) {
        wc.hIcon = (HICON)LoadImage(appInstance, L"IDI_ICON1", IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
    } else {
        wc.hIcon    = 0;
    }
#endif
    wc.lpszMenuName  = 0;
    wc.lpszClassName = reinterpret_cast<LPCWSTR>(cname.utf16());
#ifndef Q_OS_WINCE
    ATOM atom = RegisterClassEx(&wc);
#else
    ATOM atom = RegisterClass(&wc);
#endif
    if (!atom)
        qErrnoWarning("QApplication::regClass: Registering window class '%s' failed.",
                      qPrintable(cname));
    d->m_registeredWindowClassNames.insert(cname);
    qCDebug(lcQpaWindows).nospace() << __FUNCTION__ << ' ' << cname
        << " style=0x" << hex << style << dec
        << " brush=" << brush << " icon=" << icon << " atom=" << atom;
    return cname;
}
```

到这里，就看到了注册窗口的基本套路RegisterClass()，就算是彻底把跟Qt事件相关的消息循环回调找到了。

现在再来看一下刚才说的qWindowsWndProc，这里边的内容，其实比较简短：

```
extern "C" LRESULT QT_WIN_CALLBACK qWindowsWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT result;
    const QtWindows::WindowsEventType et = windowsEventType(message, wParam, lParam);
    const bool handled = QWindowsContext::instance()->windowsProc(hwnd, message, et, wParam, lParam, &result);
    if (QWindowsContext::verbose > 1 && lcQpaEvents().isDebugEnabled()) {
        if (const char *eventName = QWindowsGuiEventDispatcher::windowsMessageName(message)) {
            qCDebug(lcQpaEvents) << "EVENT: hwd=" << hwnd << eventName << hex << "msg=0x"  << message
                << "et=0x" << et << dec << "wp=" << int(wParam) << "at"
                << GET_X_LPARAM(lParam) << GET_Y_LPARAM(lParam) << "handled=" << handled;
        }
    }
    if (!handled)
        result = DefWindowProc(hwnd, message, wParam, lParam);
    return result;
}
```

在这里主要做了一些微小的工作，对消息分类把消息处理成QtWindow::WindowEventType类型，便于后续处理，具体逻辑在windowsEventType()方法中，主要是做Win32消息和Qt事件的映射。然后就是调用
QWindowsContext::windowsProc()处理消息。特定情况下输出debug信息。在处理消息的时候会得到处理结果，对于没有处理的调用DefWindowProc()做默认处理。

**如果想看Win32消息和Qt事件对应的关系映射，在上边说到的windowEventType()方法中是最快的，基本涵盖了大部分，但是要注意有一些名字对不上，因为到这里其实分类还不是QEvent，而是一个中间类型**

现在来重点关注一下windowProc()方法。

```
bool QWindowsContext::windowsProc(HWND hwnd, UINT message,
                                  QtWindows::WindowsEventType et,
                                  WPARAM wParam, LPARAM lParam, LRESULT *result)
{
    *result = 0;
    MSG msg;
    msg.hwnd = hwnd;         // re-create MSG structure
    msg.message = message;   // time and pt fields ignored
    msg.wParam = wParam;
    msg.lParam = lParam;
    msg.pt.x = msg.pt.y = 0;
    if (et != QtWindows::CursorEvent && (et & (QtWindows::MouseEventFlag | QtWindows::NonClientEventFlag))) {
        msg.pt.x = GET_X_LPARAM(lParam);
        msg.pt.y = GET_Y_LPARAM(lParam);
        // For non-client-area messages, these are screen coordinates (as expected
        // in the MSG structure), otherwise they are client coordinates.
        if (!(et & QtWindows::NonClientEventFlag)) {
            ClientToScreen(msg.hwnd, &msg.pt);
        }
    } else {
#ifndef Q_OS_WINCE
        GetCursorPos(&msg.pt);
#endif
    }
    // Run the native event filters.
    long filterResult = 0;
    QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::instance();
    if (dispatcher && dispatcher->filterNativeEvent(d->m_eventType, &msg, &filterResult)) {
        *result = LRESULT(filterResult);
        return true;
    }
    QWindowsWindow *platformWindow = findPlatformWindow(hwnd);
    if (platformWindow) {
        filterResult = 0;
        if (QWindowSystemInterface::handleNativeEvent(platformWindow->window(), d->m_eventType, &msg, &filterResult)) {
            *result = LRESULT(filterResult);
            return true;
        }
    }
    if (et & QtWindows::InputMethodEventFlag) {
        QWindowsInputContext *windowsInputContext = ::windowsInputContext();
        // Disable IME assuming this is a special implementation hooking into keyboard input.
        // "Real" IME implementations should use a native event filter intercepting IME events.
        if (!windowsInputContext) {
            QWindowsInputContext::setWindowsImeEnabled(platformWindow, false);
            return false;
        }
        switch (et) {
        case QtWindows::InputMethodStartCompositionEvent:
            return windowsInputContext->startComposition(hwnd);
        case QtWindows::InputMethodCompositionEvent:
            return windowsInputContext->composition(hwnd, lParam);
        case QtWindows::InputMethodEndCompositionEvent:
            return windowsInputContext->endComposition(hwnd);
        case QtWindows::InputMethodRequest:
            return windowsInputContext->handleIME_Request(wParam, lParam, result);
        default:
            break;
        }
    } // InputMethodEventFlag
    //...
    if (platformWindow) {
        // Suppress events sent during DestroyWindow() for native children.
        if (platformWindow->testFlag(QWindowsWindow::WithinDestroy))
            return false;
        if (QWindowsContext::verbose > 1)
            qCDebug(lcQpaEvents) << "Event window: " << platformWindow->window();
    } else {
        qWarning("%s: No Qt Window found for event 0x%x (%s), hwnd=0x%p.",
                 __FUNCTION__, message,
                 QWindowsGuiEventDispatcher::windowsMessageName(message), hwnd);
        return false;
    }
    switch (et) {
    case QtWindows::KeyboardLayoutChangeEvent:
        if (QWindowsInputContext *wic = windowsInputContext())
            wic->handleInputLanguageChanged(wParam, lParam); // fallthrough intended.
    case QtWindows::KeyDownEvent:
    case QtWindows::KeyEvent:
    case QtWindows::InputMethodKeyEvent:
    case QtWindows::InputMethodKeyDownEvent:
    case QtWindows::AppCommandEvent:
#if !defined(Q_OS_WINCE) && !defined(QT_NO_SESSIONMANAGER)
        return platformSessionManager()->isInteractionBlocked() ? true : d->m_keyMapper.translateKeyEvent(platformWindow->window(), hwnd, msg, result);
#else
        return d->m_keyMapper.translateKeyEvent(platformWindow->window(), hwnd, msg, result);
#endif
    //...
    case QtWindows::MouseWheelEvent:
    case QtWindows::MouseEvent:
    case QtWindows::LeaveEvent:
#if !defined(Q_OS_WINCE) && !defined(QT_NO_SESSIONMANAGER)
        return platformSessionManager()->isInteractionBlocked() ? true : d->m_mouseHandler.translateMouseEvent(platformWindow->window(), hwnd, et, msg, result);
#else
        return d->m_mouseHandler.translateMouseEvent(platformWindow->window(), hwnd, et, msg, result);
#endif
    case QtWindows::TouchEvent:
#if !defined(Q_OS_WINCE) && !defined(QT_NO_SESSIONMANAGER)
        return platformSessionManager()->isInteractionBlocked() ? true : d->m_mouseHandler.translateTouchEvent(platformWindow->window(), hwnd, et, msg, result);
#else
        return d->m_mouseHandler.translateTouchEvent(platformWindow->window(), hwnd, et, msg, result);
#endif
    case QtWindows::FocusInEvent: // see QWindowsWindow::requestActivateWindow().
    case QtWindows::FocusOutEvent:
        handleFocusEvent(et, platformWindow);
        return true;
    case QtWindows::ShowEventOnParentRestoring: // QTBUG-40696, prevent Windows from re-showing hidden transient children (dialogs).
        if (!platformWindow->window()->isVisible()) {
            *result = 0;
            return true;
        }
        break;
    //...
    }
   //...
    return false;
}
```

本着太长不看的原则，我把一些相似的都省略掉了。这里就能看到在这里会根据消息类型来进行分类处理。处理的方式也是统一的，调用handleXXXXEvent()或是tranlateXXXXEvent()。需要二次加工的就要走到tranlateXXXXEvent()二次加工。最终其实都是走到handleXXXXEvent()。而handleXXXXEvent()方法中会将事件包装成一个新的类型，再统一调用
QWindowSystemInterfacePrivate::handleWindowSystemEvent(e)**PS:这是个静态方法**，这个静态方法中需要关注postWindowSystemEvent()。

现在来看postWindowSystemEvent()：

```
void QWindowSystemInterfacePrivate::postWindowSystemEvent(WindowSystemEvent *ev)
{
    windowSystemEventQueue.append(ev);
    QAbstractEventDispatcher *dispatcher = QGuiApplicationPrivate::qt_qpa_core_dispatcher();
    if (dispatcher)
        dispatcher->wakeUp();
}
```

看到了非常熟悉的一个队列windowSystemEventQueue，就是在这里将事件加入队列，至此整个Qt事件和Windows消息循环彻底联系起来……

其实这只是一个添加事件、获取事件的简单流程，仅仅为了研究Qt事件和Windows消息循环的联系。 在这中间省略的很多其他细节，包括注册窗口，反注册，具体的事件处理规则，还有一些防止事件错误发送的保护机制，都是很好的研究内容……

原文作者：音视频开发老舅

原文地址：http://t.csdn.cn/oaMqE



# 【NO.62】、Qt5 中的 Json 模块与 JsonCpp 的对比

注：大家常说的 **QJson** 其实并不是 Qt 中的模块，而是在 Qt4 没有 Json 模块的年代，一个非官方的第三方模块。对于现在 Qt 中的 Json 模块，官方称之为 **Qt Json**。

其实 Qt5 中的 Qt Json 模块的代码，写的可以说是严格按照 ECMA-404 协议的解析范本，没有任何自己画蛇添足的逻辑。而相比之下，JsonCpp 就相当随意了，作为一个非常有个性的解析器，是当之无愧了。以至于从 JsonCpp 换到 Qt Json 着实要做些兼容工作。

## 1、二者的细节对比：

### 1.1、Qt Json

1. 不支持C/C++风格注释，解析失败
2. 不支持0123456这种数值解析
3. 不支持QJsonValue、QJsonDocument的直接比较大小(支持判断相等和不等)
4. 允许设置默认值，不抛异常。没有设置默认值的，无法转换成功返回空值。
5. 错误信息不可定位到具体行列
6. Json文本最大不能超过128MB(超过会爆DocumentTooLargeError)
7. 最大不能超过1024层嵌套(超过会爆DeepNestingError) (以上两个限制都是写死在代码的，可以改掉，但是改掉限制以后。是否有其他问题暂不清楚)
8. qDebug下支持直接输出 Qt Json 的相关对象

### 1.2、JsonCpp

1. 支持C/C++风格注释，可以选择是否解析注释，可以允许设置和获取注释(然而在FastWriter的情况下不会输出注释)
2. 支持0123456这种数值的解析
3. 支持JsonValue的直接比较
4. 不允许设置默认值，对于无法转换成功的，直接抛异常
5. 错误信息可以定位到具体行列

## 2、总结

对于二者的效率，只用了 JsonCpp 项目中的测试用例跑过，结果证明 Qt Json 性能会好大概3-5倍。而且对于 Qt 项目来说， JsonCpp 那种解析错误就抛异常的，显然有点激进了，利用 Qt 的信号和槽就优雅了很多。但是由于 Qt 开发人员的懒惰，使用递归来进行解析，导致对 Json 数据的嵌套层数有要求，算是一个遗憾。不过客户端应用也够用了。

工作中对 JsonCpp 的兼容也只是兼容了 JsonCpp 的第1、2条。对 Qt Json 模块只要改 parse 部分。而 Qt Json 的 parse 是一个状态机，代码也通俗易懂，改起来还是不难的。另外一部分内容就是 Qt5 Json 向 Qt4 移植，这块的话，还是要稍微看一下源码，改动的话需要调整 Qt4 中的 QString 以及 QAtomicInt 中的一些原子操作，主要是一些琐碎细节，没啥特色，也就不表了。

很遗憾的是这两个库都只支持 DOM 解析

论专业性，还是 RapidJson 好一点，还支持 SAX 解析，而且在性能上会比较拔群。

原文作者：音视频开发老舅

原文地址：http://t.csdn.cn/0EDIQ



# 【NO.63】、Qt中translate、tr关系 与中文问题

## 1、何时使用 tr ？

在论坛中漂，经常遇到有人遇到tr相关的问题。用tr的有两类人：

- (1)因为发现中文老出问题，然后搜索，发现很多人用tr，于是他也开始用tr
- (2)另一类人，确实是出于国际化的需要，将需要在界面上显示的文件都用tr包起来，这有分两种： (2a) 用tr包住英文(最最推荐的用法，源码英文，然后提供英文到其他语言的翻译包)(2b) 用tr包住中文(源码用中文，然后提供中文到其他语言的翻译包)

**注意哦，如果你正在用tr包裹中文字符，却不属于(2b)，那么，这是个信号：**

- 你在误用tr
- 你需要的是QString，而不是tr

**如果你确实属于(2b)，请做好心理准备，你可能还会遇到很多困难,请考虑**Qt国际化（源码含中文时）的点滴分析 **tr 是做什么的？下面二者的区别是什么？**

```
QString text1 = QObject::tr("hello");
 QString text2 = QString("hello");
```

tr是用来实现国际化，如果你为这个程序提供了中文翻译包(其中hello被翻译成中文"你好")，那么text1的内容将是中文"你好"；如果你为程序提供且使用日文翻译包，那么text1的内容将是日文。

tr是经过多级函数调用才实现了翻译操作，是有代价的，所以不该用的时候最好不要用。

## 2、关注的对象

本文关注的是tr或translate中包含中文字符串的情况：

- QObject::tr()
- QCoreApplication::translate()
- QTextCodec::setCodecForTr

这个问题本多少可说的。因为涉及到的编码问题和QString 与中文问题中是完全一样的，只不过一个是用的setCodecForCStrings一个用的是setCodecForTr。

**简单回顾QString的中文问题**

- QString 采用的unicode，在中文支持上不存在任何问题
- "我是中文" 这是传统的 const char * 的窄字符串
- 当将窄字符串赋值到QString时，我们需要告诉它我们的窄串采用的何种编码(gbk?、utf-8?)
- 究竟何种编码主要取决于我们的源代码文件的编码(windows上一般是gbk，其他平台一般utf-8)

例子：

```
QString s1 = "我是中文";
QString s2("我是中文");
QString s3;
s3 = "我是中文"
```

- s1、s2 用的是QString的构造函数QString ( const char * str )
- s3 用的是QString的赋值操作符 QString & operator= ( const char * str)

如果不指定编码，s1,s2,s3将全部都是(国内大多数人所称的)乱码。因为QString将这些const char *按照latin1来解释的，而不是用户期待的gbk或utf8。

```
QTextCodec::setCodecForCStrings(QTextCodec::codecForName("GB2312"));
QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8"))
```

这两条语句中的一条可以解决问题，至于如何选择，此处不再重复。

### 2.1QObject::tr

说实话，在tr中使用中文不是个好主意。不过既然总有人用（无论是(1)还是(2b)），而且总有人遇到问题，所以还是简单整理一下吧。

相比QCoreApplication::translate，大家用tr应该用的很多了，尽管不少人不清楚tr究竟是做什么的^_^

```
tr("我是中文");
```

这调用的是下面这个函数(至少我们可这么认为是)。

```
QString QObject::tr ( const char * sourceText, const char * disambiguation = 0, int n = -1 )
```

与QString("我是中文")完全一样，你必须告诉tr这个窄字符串是何种编码？你不告诉它，它就用latin1。于是所谓的乱码问题就出来了。

如何告诉tr你写的这几个汉字在磁盘中保存的是何种编码呢？这正是

```
QTextCodec::setCodecForTr(QTextCodec::codecForName("GB2312")); 
QTextCodec::setCodecForTr(QTextCodec::codecForName("UTF-8"));
```

所做的。这两个选择的原则，由于和前文完全一样，此处也不再重复。

如果你的编码采用的utf8，可以直接使用trUtf8而不必设置setCodecForTr。

如果你只关心乱码问题，到此为止就可以了(下面不再关注编码)。如果想对tr进一步了解，不妨。。继续。。

### **2.2、QCoreApplication::translate**

我们知道tr是用于实现程序的国际化(或者说多语言翻译)，看Qt相关资料的话，我们知道实现该功能的还有下面这个函数：

```
QString QCoreApplication::translate ( const char * context, const char * sourceText, const char * disambiguation, Encoding encoding, int n )
```

其实，这个才是真正进行翻译操作的函数，前面我们提到的tr最终是通过调用该函数来实现翻译功能的(稍后我们会看tr是如何调用translate的)。

对tr和这个函数，manual中都有比较详尽的解释。我们这儿简单看一下它的这几个参数：

- context 上下文，一般就是需要翻译的字符串所在的类的名字
- sourceText 需要翻译的字符串。(我们关注的编码其实就是它的编码)
- disambiguation 消除歧义用的。(比如我们的类内出现两处"close"，一处含义是关闭，另一处含义是亲密的。显然需要让翻译人员知道这点区别)
- encoding 指定编码。它有两个值 CodecForTr 使用setCodecForTr()设置的编码来解释 sourceText UnicodeUTF8 使用utf8编码来解释 sourceText其实这两个分别对应tr和trUtf8
- n 处理单复数(对中文来说，不存在这个问题)

### **2.3、tr与translate**

这两个函数的说明，一个在QObject的manual，另一个在QCoreApplication的manual中。

介绍一下tr与translate的关系。前面提到了，tr调用的是translate。如果仅仅这样一说，没有证据，还真难以让大家相信。好吧，继续

## 3、tr 在何处定义

你可能说：这不废话吗，manual中写得明白的，它是QObject的静态成员函数。而且还有源码为证：

```
//来自 src/corelib/kernel/qobject.h 
#ifdef qdoc 
static QString tr(const char *sourceText, const char *comment = 0, int n = -1);
static QString trUtf8(const char *sourceText, const char *comment = 0, int n = -1);
#endif
```

嘿嘿，差点就被骗了，发现没：它们被预处理语句包住了。

这说明了什么呢？说明了这段代码**仅仅是**用来生成Qt那漂亮的文档的(qdoc3从代码中抽取信息，生成一系列的html格式的manual)。

啊，也就是说，这是假的。那么真正的定义呢？？在一个大家都很熟悉的地方,猜猜看？

这就是

```
Q_OBJECT
```

该宏的定义在src/corelib/kernel/qobjectdefs.h中

```
#define Q_OBJECT /
 public: /
 Q_OBJECT_CHECK /
 static const QMetaObject staticMetaObject; /
 Q_OBJECT_GETSTATICMETAOBJECT /
 virtual const QMetaObject *metaObject() const; /
 virtual void *qt_metacast(const char *); /
 QT_TR_FUNCTIONS /
 virtual int qt_metacall(QMetaObject::Call, int, void **); /
 private:
```

其中的宏QT_TR_FUNCTIONS

```
#  define QT_TR_FUNCTIONS /
 static inline QString tr(const char *s, const char *c = 0) /
 { return staticMetaObject.tr(s, c); } /
 static inline QString trUtf8(const char *s, const char *c = 0) /
 { return staticMetaObject.trUtf8(s, c); } /
 static inline QString tr(const char *s, const char *c, int n) /
 { return staticMetaObject.tr(s, c, n); } /
 static inline QString trUtf8(const char *s, const char *c, int n) /
 { return staticMetaObject.trUtf8(s, c, n); }
```

现在看到：tr调用的是 staticMetaObject对象的tr函数，staticMetaObject 的定义在moc生成的 xxx.moc 或 moc_xxx.cpp 文件内(你随时可以验证的)。

staticMetaObject 是一个 QMetaObject 类的实例，我们继续看一下该类的源码：

```
/*!
 /internal 
*/
 QString QMetaObject::tr(const char *s, const char *c) const
 {
 return QCoreApplication::translate(d.stringdata, s, c, QCoreApplication::CodecForTr);
 }
 /*!
 /internal 
*/ 
QString QMetaObject::trUtf8(const char *s, const char *c) const 
{     
return QCoreApplication::translate(d.stringdata, s, c, QCoreApplication::UnicodeUTF8); 
}
```

至此，我们应该都看清楚了。我们的 Q_OBJECT 宏展开后为生成 tr ，tr调用QCoreApplication的translate函数。而该函数需要指定编码。

原文作者：音视频开发老舅

原文地址：http://t.csdn.cn/hUyA7